<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>哨笛简谱工坊 (Tin Whistle Tab Maker)</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @media print {
      @page { margin: 1cm; }
      body { -webkit-print-color-adjust: exact; background: white; }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // Lucide React Icons as inline SVG components
    const Printer = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z" />
      </svg>
    );

    const Music = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
      </svg>
    );

    const Info = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
    );

    const Eraser = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
      </svg>
    );

    const FileText = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
      </svg>
    );

    const Settings = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
    );

    const WhistleTabMaker = () => {
      // Default song: Down by the Salley Gardens (Fragment)
      const defaultText = `1 2 3 5/ 6/ | 1+ 6 5 - | (3 3)
3 1 2 3/ 5/ | 6 5 - - | (3 ~ 3)
1+ 6 5 3 | 1 2 3/ 5/ | 6 5 - - |`;

      const [input, setInput] = useState(defaultText);
      const [selectedKey, setSelectedKey] = useState('D'); // D, G, A, C, etc.
      const [barsPerLine, setBarsPerLine] = useState(4);
  
  // D Major Whistle Fingering Map 
  // 1 = Closed, 0 = Open, 0.5 = Half Hole
  // Format: [Top Hole (Hole 6), ..., Bottom Hole (Hole 1)]
  // Standard scale: D(1), E(2), F#(3), G(4), A(5), B(6), C#(7)
  const baseFingerings = {
    // --- Low Octave ---
    'L1':  [1, 1, 1, 1, 1, 1], // D
    'L1#': [1, 1, 1, 1, 1, 0.5], // D# / Eb (Half hole)
    'L2':  [1, 1, 1, 1, 1, 0], // E
    'L2#': [1, 1, 0, 1, 1, 0], // F Natural (Cross fingering) or [1,1,1,1,0.5,0]
    'L3':  [1, 1, 1, 1, 0, 0], // F#
    'L4':  [1, 1, 1, 0, 0, 0], // G
    'L4#': [1, 1, 1, 0.5, 0, 0], // G# (Half hole)
    'L5':  [1, 1, 0, 0, 0, 0], // A
    'L5#': [1, 0, 1, 0, 0, 0], // Bb (Cross fingering OXXOOO is C-nat, XOXOOO is Bb usually) - Using XOX OOO for Bb
    'L6':  [1, 0, 0, 0, 0, 0], // B
    'L7b': [0, 1, 1, 0, 0, 0], // C Natural (OXX OOO)
    'L7':  [0, 0, 0, 0, 0, 0], // C#

    // --- Middle Octave (Standard Range 1) ---
    '1':   [1, 1, 1, 1, 1, 1], // D
    '1#':  [1, 1, 1, 1, 1, 0.5], // D#
    '2':   [1, 1, 1, 1, 1, 0], // E
    '2#':  [1, 1, 0, 1, 1, 0], // F Natural (Cross)
    '3':   [1, 1, 1, 1, 0, 0], // F#
    '4':   [1, 1, 1, 0, 0, 0], // G
    '4#':  [1, 1, 1, 0.5, 0, 0], // G#
    '5':   [1, 1, 0, 0, 0, 0], // A
    '5#':  [1, 0, 1, 0, 0, 0], // Bb (A#)
    '6':   [1, 0, 0, 0, 0, 0], // B
    '7b':  [0, 1, 1, 0, 0, 0], // C Natural
    '7':   [0, 0, 0, 0, 0, 0], // C#

    // --- High Octave (Range 2) ---
    'H1':  [0, 1, 1, 1, 1, 1], // High D
    'H1#': [0, 1, 1, 1, 1, 0.5], // High D#
    'H2':  [1, 1, 1, 1, 1, 0], // High E
    'H2#': [1, 1, 0, 1, 1, 0], // High F Nat
    'H3':  [1, 1, 1, 1, 0, 0], // High F#
    'H4':  [1, 1, 1, 0, 0, 0], // High G
    'H4#': [1, 1, 1, 0.5, 0, 0], // High G#
    'H5':  [1, 1, 0, 0, 0, 0], // High A
    'H5#': [1, 0, 1, 0, 0, 0], // High Bb
    'H6':  [1, 0, 0, 0, 0, 0], // High B
    'H7b': [0, 1, 1, 0, 0, 0], // High C Nat
    'H7':  [0, 0, 0, 0, 0, 0], // High C#
  };

  // Logic to transform notes based on Key Signature
  const getKeyModifiedNote = (noteVal, keySignature) => {
    // Determine the actual note to play based on the key signature relative to D Major
    // D Major (Default): 1=D, 2=E, 3=F#, 4=G, 5=A, 6=B, 7=C#
    
    // G Major: Has C natural instead of C#. (Flatten 7)
    if (keySignature === 'G' && noteVal === '7') return '7b';

    // A Major: Has G# instead of G. (Sharp 4)
    if (keySignature === 'A' && noteVal === '4') return '4#';

    // C Major: Has F natural (Flatten 3) and C natural (Flatten 7)
    if (keySignature === 'C') {
        if (noteVal === '3') return '2#'; // F Natural (usually called flat 3 or sharp 2)
        if (noteVal === '7') return '7b';
    }
    
    // F Major (less common on D whistle, but possible): Bb (Flat 6), F nat (Flat 3), C nat (Flat 7)
    if (keySignature === 'F') {
        if (noteVal === '3') return '2#';
        if (noteVal === '6') return '5#';
        if (noteVal === '7') return '7b';
    }

    return noteVal;
  };

  // Get the note name (pitch letter) based on the note value and key
  const getNoteName = (token) => {
    // D Major scale mapping (D whistle default)
    const dMajorScale = {
      '1': 'D', '1#': 'D♯', '2': 'E', '2#': 'F', '3': 'F♯',
      '4': 'G', '4#': 'G♯', '5': 'A', '5#': 'B♭', '6': 'B', '7b': 'C', '7': 'C♯'
    };

    let noteVal = token.val;
    let acc = token.accidental;

    // Apply explicit accidentals first
    if (acc === '#') noteVal = noteVal + '#';
    else if (acc === 'b') {
      if (noteVal === '7') noteVal = '7b';
      else if (noteVal === '3') noteVal = '2#';
      else noteVal = noteVal + '#';
    } else {
      // Apply key signature modifications
      noteVal = getKeyModifiedNote(noteVal, selectedKey);
    }

    // Get base note name from D Major scale
    let noteName = dMajorScale[noteVal] || dMajorScale[token.val] || 'D';
    
    // Adjust for different keys
    if (selectedKey === 'G') {
      // G Major: 1=G, 2=A, 3=B, 4=C, 5=D, 6=E, 7=F#
      const gMajorMap = {'1': 'G', '2': 'A', '3': 'B', '4': 'C', '5': 'D', '6': 'E', '7': 'F♯', '7b': 'F'};
      noteName = gMajorMap[token.val + (acc || '')] || gMajorMap[token.val] || noteName;
    } else if (selectedKey === 'A') {
      // A Major: 1=A, 2=B, 3=C#, 4=D, 5=E, 6=F#, 7=G#
      const aMajorMap = {'1': 'A', '2': 'B', '3': 'C♯', '4': 'D', '4#': 'D♯', '5': 'E', '6': 'F♯', '7': 'G♯'};
      noteName = aMajorMap[noteVal] || aMajorMap[token.val] || noteName;
    } else if (selectedKey === 'C') {
      // C Major: 1=C, 2=D, 3=E, 4=F, 5=G, 6=A, 7=B
      const cMajorMap = {'1': 'C', '2': 'D', '2#': 'D♯', '3': 'E', '4': 'F', '5': 'G', '6': 'A', '7': 'B', '7b': 'B♭'};
      noteName = cMajorMap[noteVal] || cMajorMap[token.val] || noteName;
    }

    return noteName;
  };

  // Parser Logic
  const parseNotes = (text) => {
    // Pre-process to ensure barlines are separated
    const processedText = text.replace(/\|/g, ' | ');
    const lines = processedText.split('\n');
    return lines.map((line) => {
      const tokens = line.trim().split(/\s+/);
      const parsedTokens = [];
      let inSlur = false;
      
      tokens.forEach(token => {
        if (!token) return;
        
        let note = null;
        let octave = 'middle';
        let accidental = null; // '#', 'b'
        let isRest = false;
        let isSustain = false;
        let duration = 0; // Number of slashes for rhythm notation
        
        let cleanToken = token.trim();
        
        // Check for slur markers (parentheses)
        const startsSlur = cleanToken.startsWith('(');
        const endsSlur = cleanToken.endsWith(')');
        
        // Remove parentheses for parsing
        cleanToken = cleanToken.replace(/[()]/g, '');
        
        if (!cleanToken) {
          // Handle standalone parentheses
          if (startsSlur) parsedTokens.push({ type: 'slur-start' });
          if (endsSlur) parsedTokens.push({ type: 'slur-end' });
          return;
        }
        
        if (startsSlur) parsedTokens.push({ type: 'slur-start' });
        
        if (cleanToken === '0') {
          parsedTokens.push({ type: 'rest' });
        } else if (cleanToken === '-' || cleanToken === '~') {
          parsedTokens.push({ type: 'sustain' });
        } else if (cleanToken === '|') {
          parsedTokens.push({ type: 'barline' });
        } else {
          // Enhanced Regex: (accidental)(note)(accidental)(modifiers)(slashes)
          // Matches: 1, 1+, 1#, #1, 7b, b7, 5/, 5//, 5///, 5-
          const match = cleanToken.match(/^([#b]?)?([1-7])([#b]?)?([+'_-]*)?(\/{0,3})?$/);
          
          if (match) {
            const preAcc = match[1];
            const val = match[2];
            const postAcc = match[3];
            const mods = match[4] || '';
            const slashes = match[5] || '';
            
            note = val;
            accidental = preAcc || postAcc || null;
            duration = slashes.length; // 0=quarter note, 1=eighth, 2=sixteenth, 3=thirty-second
            
            if (mods.includes('+') || mods.includes("'")) octave = 'high';
            else if (mods.includes('_')) octave = 'low';
            
            // Check for bass dot modifier '-'
            const hasBassDot = mods.includes('-');

            parsedTokens.push({ type: 'note', val: note, octave, accidental, duration, hasBassDot, original: token });
          } else {
            parsedTokens.push({ type: 'text', content: cleanToken });
          }
        }
        
        if (endsSlur) parsedTokens.push({ type: 'slur-end' });
      });
      
      return parsedTokens.filter(Boolean);
    });
  };

  // Reflow tokens based on bars per line
  const reflowTokens = (tokens, barsCount) => {
    const newLines = [];
    let currentLine = [];
    let barsInCurrentLine = 0;
    let inSlur = false;

    tokens.forEach(token => {
        if (token.type === 'slur-start') inSlur = true;
        if (token.type === 'slur-end') inSlur = false;

        currentLine.push(token);

        if (token.type === 'barline') {
            barsInCurrentLine++;
            if (barsInCurrentLine >= barsCount) {
                if (inSlur) currentLine.push({ type: 'slur-end' });
                newLines.push(currentLine);
                currentLine = [];
                barsInCurrentLine = 0;
                if (inSlur) currentLine.push({ type: 'slur-start' });
            }
        }
    });

    if (currentLine.length > 0) newLines.push(currentLine);
    return newLines;
  };

  const rawParsedLines = parseNotes(input);
  const parsedLines = reflowTokens(rawParsedLines.flat(), barsPerLine);

  const getFingering = (token) => {
    let noteVal = token.val;
    let acc = token.accidental;

    // 1. Apply Key Signature transformations (only if no explicit accidental is given)
    if (!acc) {
        noteVal = getKeyModifiedNote(noteVal, selectedKey);
    } else {
        // Normalize explicit accidentals
        if (acc === '#') noteVal = noteVal + '#';
        if (acc === 'b') {
            // Convert flat to previous sharp for simplicity in map lookup, or dedicated flat entry
            // Simple mapping for this map:
            if (noteVal === '7') noteVal = '7b';
            else if (noteVal === '3') noteVal = '2#'; // Eb/D#? No 3b is F natural? No. 
            // In D Major context: 
            // 3 is F#. 3b is F natural. F natural is mapped as '2#' or special entry.
            else if (noteVal === '2') noteVal = '1#'; // Eb
            else noteVal = noteVal + '#'; // Fallback
        }
    }

    // 2. Build Lookup Key
    let key = noteVal;
    if (token.octave === 'high') key = 'H' + noteVal;
    else if (token.octave === 'low') key = 'L' + noteVal;
    
    return baseFingerings[key] || baseFingerings[noteVal] || [0,0,0,0,0,0];
  };

  const handlePrint = () => window.print();

  return (
    <div className="min-h-screen bg-slate-50 flex flex-col font-sans text-slate-800">
      <header className="bg-emerald-700 text-white p-4 shadow-md print:hidden">
        <div className="max-w-5xl mx-auto flex justify-between items-center">
          <div className="flex items-center gap-2">
            <Music className="w-6 h-6" />
            <h1 className="text-xl font-bold">哨笛简谱工坊 (Tin Whistle Tab Maker)</h1>
          </div>
          <button 
            onClick={handlePrint}
            className="flex items-center gap-2 bg-white text-emerald-800 px-4 py-2 rounded-lg hover:bg-emerald-50 transition font-medium shadow-sm"
          >
            <Printer className="w-4 h-4" />
            打印/保存PDF
          </button>
        </div>
      </header>

      <div className="flex-1 flex flex-col md:flex-row max-w-7xl mx-auto w-full p-4 gap-6">
        
        {/* Editor Panel */}
        <div className="w-full md:w-1/3 flex flex-col gap-4 print:hidden">
          
          <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200 flex-1 flex flex-col">
            <div className="flex justify-between items-center mb-2">
              <h2 className="font-semibold text-slate-700 flex items-center gap-2">
                <FileText className="w-4 h-4" />
                简谱输入
              </h2>
              <button 
                onClick={() => setInput('')}
                className="text-xs text-slate-500 hover:text-red-500 flex items-center gap-1"
              >
                <Eraser className="w-3 h-3" /> 清空
              </button>
            </div>
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              className="w-full flex-1 p-3 bg-slate-50 border border-slate-300 rounded-lg focus:ring-2 focus:ring-emerald-500 focus:border-emerald-500 font-mono text-lg resize-none outline-none"
              placeholder="在这里输入数字..."
              spellCheck="false"
            />
            
            <div className="mt-4 bg-emerald-50 p-3 rounded-lg text-sm text-emerald-800 border border-emerald-100">
              <div className="font-semibold mb-1 flex items-center gap-1">
                <Info className="w-4 h-4" /> 输入指南:
              </div>
              <ul className="space-y-1 list-disc list-inside opacity-90 text-xs">
                <li><code className="bg-white px-1 border rounded">1-7</code> : 中音 (例如: 1)</li>
                <li><code className="bg-white px-1 border rounded">+</code> : 高音 (例如: 1+)</li>
                <li><code className="bg-white px-1 border rounded">#</code> / <code className="bg-white px-1 border rounded">b</code> : 升降 (例如: 4# 或 7b)</li>
                <li><code className="bg-white px-1 border rounded">/</code> : 时值 (例如: 5/ 八分, 5// 十六分, 5/// 三十二分)</li>
                <li><code className="bg-white px-1 border rounded">()</code> : 连音线 (例如: (3 5) 表示连音)</li>
                <li><code className="bg-white px-1 border rounded">|</code> : 小节分隔符</li>
                <li><code className="bg-white px-1 border rounded">0</code> : 休止符 | <code className="bg-white px-1 border rounded">~</code> : 延音</li>
              </ul>
            </div>
          </div>

          {/* Settings */}
          <div className="bg-white p-4 rounded-xl shadow-sm border border-slate-200">
             <div className="flex items-center gap-2 mb-3">
                <Settings className="w-4 h-4 text-slate-500" />
                <h2 className="font-semibold text-slate-700">选项设置</h2>
             </div>
             
             <div className="space-y-4">
                <div>
                    <label className="text-sm text-slate-500 block mb-1">每行小节数</label>
                    <div className="flex gap-2">
                        {[3, 4].map(num => (
                            <button
                                key={num}
                                onClick={() => setBarsPerLine(num)}
                                className={`flex-1 py-1.5 rounded-md text-sm border transition-colors ${
                                barsPerLine === num
                                ? 'bg-emerald-600 text-white border-emerald-600 ring-2 ring-emerald-100' 
                                : 'bg-white text-slate-600 border-slate-300 hover:bg-slate-50'
                                }`}
                            >
                                {num} 小节
                            </button>
                        ))}
                    </div>
                </div>

                <div>
                    <label className="text-sm text-slate-500 block mb-1">指法调式 (D调哨笛)</label>
                    <div className="grid grid-cols-2 gap-2">
                        {[
                            { id: 'D', label: 'D调 (标准)' },
                            { id: 'G', label: 'G调 (还原C)' },
                            { id: 'A', label: 'A调 (升G)' },
                            { id: 'C', label: 'C调 (还原F,C)' },
                        ].map(key => (
                            <button
                                key={key.id}
                                onClick={() => setSelectedKey(key.id)}
                                className={`py-1.5 px-3 rounded-md text-sm border text-left transition-colors ${
                                selectedKey === key.id
                                ? 'bg-emerald-600 text-white border-emerald-600 ring-2 ring-emerald-100' 
                                : 'bg-white text-slate-600 border-slate-300 hover:bg-slate-50'
                                }`}
                            >
                                <span className="font-medium">{key.id}</span> <span className="text-xs opacity-80">{key.label.replace(key.id, '')}</span>
                            </button>
                        ))}
                    </div>
                </div>
             </div>
          </div>
        </div>

        {/* Preview Panel */}
        <div className="w-full md:w-2/3 bg-white shadow-lg rounded-xl overflow-hidden print:shadow-none print:w-full print:absolute print:top-0 print:left-0">
          <div className="p-8 min-h-[800px] print:min-h-0">
            <div className="text-center mb-8 border-b border-slate-200 pb-4">
               <h1 className="text-3xl font-serif text-slate-800 mb-2">哨笛演奏谱</h1>
               <div className="flex justify-center gap-4 text-sm text-slate-400">
                    <span>Key: {selectedKey} Major</span>
                    <span>Whistle: High D</span>
               </div>
            </div>

            <div className="space-y-6">
              {parsedLines.map((line, lineIdx) => {
                // Pre-calculate slur groups for this line
                const slurGroups = [];
                let currentSlurGroup = null;
                
                line.forEach((token, idx) => {
                  if (token.type === 'slur-start') {
                    currentSlurGroup = { start: idx, notes: [] };
                  } else if (token.type === 'slur-end') {
                    if (currentSlurGroup) {
                      currentSlurGroup.end = idx;
                      slurGroups.push(currentSlurGroup);
                      currentSlurGroup = null;
                    }
                  } else if (token.type === 'note' && currentSlurGroup) {
                    currentSlurGroup.notes.push(idx);
                  }
                });
                
                // Count visible elements in this line
                const noteCount = line.filter(t => t.type === 'note' || t.type === 'barline' || t.type === 'rest' || t.type === 'sustain').length;
                
                // Calculate scale based on note count (adjust to fit viewport)
                let scaleClass = 'text-xl';
                let holeSize = 'w-3 h-3';
                let barHeight = 'h-20';
                let whistleHeightPx = 90; // Default height for w-3 h-3 (12px*6 + 2px*5 + 4px*2)
                let currentFontSizePx = 20; // Default text-xl (1.25rem * 16px)
                
                if (noteCount > 25) {
                  scaleClass = 'text-sm';
                  holeSize = 'w-2 h-2';
                  barHeight = 'h-12';
                  whistleHeightPx = 66; // w-2 h-2 (8px*6 + 2px*5 + 4px*2)
                  currentFontSizePx = 14;
                } else if (noteCount > 18) {
                  scaleClass = 'text-base';
                  holeSize = 'w-2.5 h-2.5';
                  barHeight = 'h-16';
                  whistleHeightPx = 78; // w-2.5 h-2.5 (10px*6 + 2px*5 + 4px*2)
                  currentFontSizePx = 16;
                } else if (noteCount > 12) {
                  scaleClass = 'text-lg';
                  holeSize = 'w-2.5 h-2.5';
                  barHeight = 'h-18';
                  whistleHeightPx = 78;
                  currentFontSizePx = 18;
                }
                
                // Dynamic Gap Calculation
                const baseGap = 16; // Start with a wider gap
                const reductionThreshold = 10; // Start reducing after this many elements
                const reductionRate = 0.8; // Pixels to remove per extra element
                let dynamicGap = baseGap;
                
                if (noteCount > reductionThreshold) {
                    dynamicGap = Math.max(2, baseGap - (noteCount - reductionThreshold) * reductionRate);
                }

                const gapPx = dynamicGap;
                const gapEm = gapPx / currentFontSizePx;
                
                // Determine alignment: justify-between if full line, justify-start otherwise
                const barCount = line.filter(t => t.type === 'barline').length;
                const isFullLine = barCount === barsPerLine;
                const justifyClass = isFullLine ? 'justify-between' : 'justify-start';

                return (
                <div key={lineIdx} className={`flex items-end mb-6 leading-none relative ${scaleClass} ${justifyClass}`} style={{ paddingTop: '40px', gap: `${dynamicGap}px` }}>
                  {line.map((token, tokenIdx) => {
                    
                    // Handle slur markers
                    if (token.type === 'slur-start' || token.type === 'slur-end') {
                      return null;
                    }
                    
                    if (token.type === 'note') {
                      const holes = getFingering(token);
                      const noteName = getNoteName(token);
                      
                      // Check for beam connections (Eighth/Sixteenth notes)
                      const prevToken = tokenIdx > 0 ? line[tokenIdx - 1] : null;
                      const nextToken = tokenIdx < line.length - 1 ? line[tokenIdx + 1] : null;
                      
                      // Connect if adjacent note has at least one underline (duration > 0)
                      const connectsLeft = prevToken?.type === 'note' && prevToken.duration > 0 && token.duration > 0;
                      const connectsRight = nextToken?.type === 'note' && nextToken.duration > 0 && token.duration > 0;
                      
                      // Reduce spacing if connected to any side
                      const spacingClass = (connectsLeft || connectsRight) ? '-mx-1' : '';
                      
                      // Check if this is the first note in a slur group - render slur
                      let slurWidth = 0;
                      slurGroups.forEach(group => {
                        if (group.notes[0] === tokenIdx && group.notes.length > 1) {
                          const firstIdx = group.notes[0];
                          const lastIdx = group.notes[group.notes.length - 1];
                          
                          // Calculate precise width based on elements between start and end
                          let totalWidthEm = 0;
                          
                          for (let k = firstIdx; k < lastIdx; k++) {
                            const t1 = line[k];
                            const t2 = line[k+1];
                            
                            // Estimate width of current element (half)
                            let w1 = 2; // default note width 2em
                            if (t1.type === 'barline') w1 = 0.5;
                            else if (t1.type === 'rest') w1 = 1.5;
                            else if (t1.type === 'sustain') w1 = 1;
                            else if (t1.type === 'text') w1 = 1;
                            
                            // Estimate width of next element (half)
                            let w2 = 2;
                            if (t2.type === 'barline') w2 = 0.5;
                            else if (t2.type === 'rest') w2 = 1.5;
                            else if (t2.type === 'sustain') w2 = 1;
                            else if (t2.type === 'text') w2 = 1;
                            
                            let currentGap = gapEm;
                            // Check for compact spacing (connected beams)
                            if (t1.type === 'note' && t2.type === 'note' && 
                                t1.duration > 0 && t2.duration > 0) {
                                currentGap = 0; // -mx-1 cancels gap
                            }
                            
                            totalWidthEm += (w1/2 + currentGap + w2/2);
                          }
                          slurWidth = totalWidthEm;
                        }
                      });
                      
                      return (
                        <div 
                          key={tokenIdx} 
                          className={`flex flex-col items-center group relative min-w-[2em] ${spacingClass}`}
                        >
                          {/* Slur line using CSS */}
                          {slurWidth > 0 && (
                            <div 
                              className="absolute pointer-events-none"
                              style={{
                                top: '-35px',
                                left: '50%',
                                width: `${slurWidth}em`,
                                height: '25px',
                                borderTop: '2px solid rgb(71, 85, 105)',
                                borderRadius: '50%',
                                transform: 'scaleY(0.7)',
                                transformOrigin: 'left bottom'
                              }}
                            />
                          )}
                          
                          {/* Jianpu Number */}
                          <div className="font-bold font-mono mb-5 relative pb-3">
                            {token.octave === 'high' && (
                              <div className="absolute -top-3 left-1/2 -translate-x-1/2 w-1.5 h-1.5 rounded-full bg-slate-800"></div>
                            )}
                            
                            {/* Accidental Display */}
                            <span className="text-slate-800 relative inline-block">
                                {token.accidental && (
                                    <span className="absolute -left-3 top-0 text-xs scale-75 font-normal opacity-80">
                                        {token.accidental}
                                    </span>
                                )}
                                {token.val}
                                {/* Duration underlines - SVG (bottom-up per-line rendering) */}
                                {token.duration > 0 && (
                                  (() => {
                                    const connectsLeftAny = prevToken?.type === 'note' && prevToken.duration > 0;
                                    const extendLeft = connectsLeftAny ? 24 : 0; // viewBox units to extend left when linking
                                    const svgWidth = extendLeft + 16;
                                    const svgHeight = 10;
                                    const baseY = 8; // bottom baseline in viewBox
                                    const gap = 3; // spacing between lines
                                    return (
                                      <svg
                                        className="absolute pointer-events-none"
                                        style={{
                                          left: connectsLeftAny ? '-2em' : '50%',
                                          transform: connectsLeftAny ? 'none' : 'translateX(-50%)',
                                          bottom: '-12px',
                                          width: connectsLeftAny ? '3em' : '1em',
                                          height: `${svgHeight}px`
                                        }}
                                        viewBox={`0 0 ${svgWidth} ${svgHeight}`}
                                        preserveAspectRatio="none"
                                      >
                                        {Array.from({ length: token.duration }).map((_, i) => {
                                          // i = 0 -> bottom line, i increases upward
                                          const bottomIndex = i;
                                          const y = baseY - bottomIndex * gap;
                                          const linkLeft = prevToken?.type === 'note' && prevToken.duration > bottomIndex;
                                          // start at 0 if linking left; otherwise start after the left extended area
                                          // Shorten the line slightly on both sides for unconnected lines
                                          const startX = linkLeft ? 0 : extendLeft + 2; 
                                          const endX = svgWidth - 2; 
                                          return (
                                            <line
                                              key={i}
                                              x1={startX}
                                              y1={y}
                                              x2={endX}
                                              y2={y}
                                              stroke="rgb(30,41,59)"
                                              strokeWidth="1.5"
                                              strokeLinecap="butt"
                                            />
                                          );
                                        })}
                                      </svg>
                                    );
                                  })()
                                )}
                                
                                {/* Bass Dot (Low Octave Indicator below underlines) */}
                                {token.hasBassDot && (
                                  <div 
                                    className="absolute left-1/2 -translate-x-1/2 w-1.5 h-1.5 rounded-full bg-slate-800" 
                                    style={{ bottom: `-${20 + (token.octave === 'low' ? 10 : 0)}px` }}
                                  ></div>
                                )}
                            </span>
                            
                            {token.octave === 'low' && (
                              <div className="absolute -bottom-2 left-1/2 -translate-x-1/2 w-1.5 h-1.5 rounded-full bg-slate-800"></div>
                            )}
                          </div>

                          {/* Whistle Visual */}
                          <div className="bg-slate-100 rounded-full p-1 border border-slate-200 flex flex-col gap-[2px]">
                            {holes.map((state, hIdx) => (
                              <div 
                                key={hIdx} 
                                className={`
                                  rounded-full border border-slate-800 relative overflow-hidden
                                  ${holeSize}
                                  ${state === 1 ? 'bg-slate-800' : 'bg-white'}
                                `}
                              >
                                {state === 0.5 && (
                                    <div className="absolute top-0 left-0 w-full h-1/2 bg-slate-800"></div>
                                )}
                              </div>
                            ))}
                          </div>
                          
                          {/* Note Name (Pitch) - Below fingering */}
                          <div className="text-emerald-600 font-sans italic mt-1 text-xs">
                            {noteName}
                            {token.octave === 'high' && <span className="text-[0.7em]">′</span>}
                            {token.octave === 'low' && <span className="text-[0.7em] opacity-60">₀</span>}
                          </div>
                        </div>
                      );
                    }

                    if (token.type === 'barline') {
                       return (
                        <div key={tokenIdx} className="flex flex-col items-center justify-end mx0">
                          {/* Jianpu Barline */}
                          <div className="mb-5 pb-3 flex items-end justify-center">
                             <div className="bg-slate-800 w-[2px] h-6 rounded-full"></div>
                          </div>

                          {/* Whistle Barline */}
                          <div className="py-1 flex items-center justify-center">
                             <div 
                                className="bg-slate-800 w-[2px] rounded-full"
                                style={{ height: `${whistleHeightPx}px` }}
                             ></div>
                          </div>
                          
                          {/* Note Name Spacer */}
                          <div className="mt-1 text-xs opacity-0 select-none">|</div>
                        </div>
                       )
                    }

                    if (token.type === 'rest') {
                       return (
                        <div key={tokenIdx} className="flex flex-col items-center justify-end min-w-[1.5em] pb-1">
                          <span className="font-bold text-slate-800 mb-10">0</span>
                        </div>
                       )
                    }

                    if (token.type === 'sustain') {
                       return (
                        <div key={tokenIdx} className="flex flex-col items-center justify-end min-w-[1em] pb-1">
                          <span className="font-bold text-slate-400 mb-10">—</span>
                        </div>
                       )
                    }

                    return (
                       <div key={tokenIdx} className="flex flex-col items-center justify-end min-w-[1em] pb-1">
                          <span className="text-slate-600 mb-10 text-sm">{token.content}</span>
                        </div>
                    )
                  })}
                </div>
                );
              })}

              {parsedLines.length === 0 || (parsedLines.length === 1 && parsedLines[0].length === 0) ? (
                 <div className="text-center text-slate-300 italic mt-20">
                    在左侧输入简谱...
                 </div>
              ) : null}
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// Render the app
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<WhistleTabMaker />);
  </script>
</body>
</html>